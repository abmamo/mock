# module logger
from mock import logger
# faker (data generation)
from faker import Faker
# pandas (data handling)
import pandas as pd
# db models (for SQLite)
import mock.models as models
# sys
import sys
# init faker
faker = Faker()


class Generator:
    """
        use faker to generate real-looking random data.
        the generated data can be: names, jobs, address,
        currencies, and profiles. the generated data can
        be a list of SQLAlchemy object (to store in a db
        currently supports SQLite) or a list of dataframes
        (to store to a file)

        init params:
            - types: list of data types / domains
                     (limited to name, job, address, currency, profile)
            - data_size: size of data generated
    """
    def __init__(
            self,
            data_types=None,
            data_size=10000):
        # supported data types
        self.supported_data_types = ['name', 'job', 'address', 'currency', 'profile']
        # if types not specified use default
        if data_types is None:
            data_types = self.supported_data_types
        # check data types are valid
        if not all(data_type in self.supported_data_types for data_type in data_types):
            # raise error
            raise ValueError("invalid value: data_types. mock only supports: %s" % str(self.supported_data_types))
        else:
            # data types/domains
            self.data_types = data_types
        # size of data generated
        self.data_size = data_size
        # generated data in dict format
        # each type in self.type will have one
        self.all_data = {}
        # converted version of generated data in self.all_data
        # could be sqlalchemy objects or dataframes
        # depending on whether we want to write to a database
        # or save to files
        self.converted_data_db = {}
        self.converted_data_df = {}
        # db models corresponding to data generated by faker
        self.models = models

    def generate(self):
        """
            generate fake/mock data

            params:
                - nothing
            returns:
                - all_data: dict containing all generated data
                            in the format [type]data where type
                            in self.data_types
                            i.e. all_data = {"name": name_dicts}
        """
        # for each data type/domain specified
        for data_type in self.data_types:
            # log
            logger.info("generating type: %s" % data_type)
            # init empty list to store generated type/domain
            # data for instance list of names
            type_data = []
            # for specified data size
            for _ in range(self.data_size):
                # use faker to generate fake dicts & append
                if data_type == 'name':
                    type_data.append(faker.name())
                elif data_type == 'job':
                    type_data.append(faker.job())
                elif data_type == 'address':
                    type_data.append(faker.address())
                elif data_type == 'currency':
                    # generate currency
                    currency = faker.currency()
                    # append dict
                    type_data.append(
                        {'symbol': currency[0], 'name': currency[1]}
                    )
                elif data_type == 'profile':
                    type_data.append(faker.simple_profile())
            # add type/domain data to all data dict
            self.all_data[data_type] = type_data
        # return generated data
        return self.all_data

    def convert(self, to="db"):
        """
            convert generated data to appropriate format

            params:
                - to: destination (can be "db" or "f")
            returns:
                - converted data
        """
        # if data hasn't been generated
        if not self.all_data:
            # generate first
            self.generate()
        # convert to db objects
        if to == "db":
            # for each data type/domain in all data
            for data_type in self.all_data:
                # log
                logger.info("converting type: %s" % data_type)
                # generate sqlalchemy objects using
                # schema in models.py
                if data_type == "name":
                    # list to store name sqlalchemy objects in
                    name_data = []
                    # add all names
                    for name in self.all_data[data_type]:
                        # create sqlalchemy object & append
                        name_data.append(models.Person(name))
                    # add all names to converted dict
                    self.converted_data_db[data_type] = name_data
                elif data_type == "job":
                    # list to store job sqlalchemy objects in
                    job_data = []
                    # add all jobs
                    for job in self.all_data[data_type]:
                        # create sqlalchemy object & append
                        job_data.append(models.Job(job))
                    # add all jobs to converted dict
                    self.converted_data_db[data_type] = job_data
                elif data_type == "address":
                    # list to store address sqlalchemy objects in
                    address_data = []
                    # add all addresses
                    for address in self.all_data[data_type]:
                        # create sqlalchemy object & append
                        address_data.append(models.Address(address))
                    # add all addresses to converted dict
                    self.converted_data_db[data_type] = address_data
                elif data_type == "currency":
                    # list to store list of currency sqlalchemy objects in
                    currency_data = []
                    # add all currencies
                    for currency in self.all_data[data_type]:
                        # create sqlalchemy object & append
                        currency_data.append(
                            models.Currency(
                                symbol=currency["symbol"],
                                name=currency["name"]
                            )
                        )
                    # add all currencies to converted dict
                    self.converted_data_db[data_type] = currency_data
                elif data_type == "profile":
                    # list to store profile sqlalchemy objects in
                    profile_data = []
                    # add all proiles
                    for profile in self.all_data[data_type]:
                        # create sqlalchemy object & append
                        profile_data.append(
                            models.Profile(
                                username=profile["username"],
                                name=profile["name"],
                                sex=profile["sex"],
                                address=profile["address"],
                                mail=profile["mail"],
                                birthdate=profile["birthdate"]
                            )
                        )
                    # add all profiles to converted dict
                    self.converted_data_db[data_type] = profile_data
            # return converted data
            return self.converted_data_db
        # convert to files
        elif to == "f":
            # for each data type/domain
            for data_type in self.all_data:
                # log
                logger.info("converting type: %s" % data_type)
                if isinstance(self.all_data[data_type][0], str):
                    # create df
                    df = pd.DataFrame(
                        # get list of dicts all data
                        self.all_data[data_type],
                        # specify data columns
                        columns=[data_type]
                    )
                # if it is a dict we use keys to use as column names
                elif isinstance(self.all_data[data_type][0], dict):
                    df = pd.DataFrame.from_dict(self.all_data[data_type])
                # add dataframe to converted data
                self.converted_data_df[data_type] = df
            # return converted data
            return self.converted_data_df
